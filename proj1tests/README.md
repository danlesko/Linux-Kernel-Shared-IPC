## Project Test Files

The test files can be compiled via use of the Makefile by typing `make` + `ENTER` in the current directory. For testing purposes please run `testMailBox.o` first and then `testMessage.o` as the root user. Upon running make successfully, you will be reminded to run `testMailBox.o` as root since it contains create and delete mailbox methods. `testMessage.o` can be run as the local user.

### testMailBox.o

This program is what sets up the mailboxes for further testing. It also includes a few cases for error checking. Starting from inside `int main()` four mailboxes are attempted to be made with ID's 1, 2, 2, and 3. An error is thrown on the duplicate ID # 2 being created. Afterwards, mailbox # 3 is deleted and the number of mailboxes leftover are counted, stored in the variable `k` and passed to the list_mbox_syscall function in order to return the remaining ID's: 1 and 2. This program successfully shows the implementation of all mailbox implementation functionalities as well as displays some of the error catching that has been included in the development of the program.

### testMessage.o

This program is what adds messages to a mailbox for further testing. It, too, includes a few cases for error checking. Starting from inside `int main()` an additional mailbox with ID # 5 is created. This mailbox also has `enable_crypt` enabled as well as `lifo` enabled. We then create two messages, calculate their lengths, and create keys to use for our cipher. The messages are passed via the send_msg_syscall where they are stored encrypted in the mailbox in LIFO order. Next, we call a function to obtain the length of message 2, as the messages are stored in LIFO order. We will get a return of 15, which is the number of bytes contained in msg2. Afterwards we receive the message and print it out which will print message 2. We then count the number of messages left which is 1, as we just received 1 message. Now we peek the next message, which in this case is msg1. Again we print this message to the screen and do a count again. The count of messages remains 1 since we only peaked. Again we receive the message which clears the mailbox and print it to the screen. After finally receiving the last message, we do one more count to show that the mailbox has been fully cleared. We know it is cleared because a negative value was returned, which we use to set numMsgs to 0 for clarification to the user. This program successfully shows the implementation of all message implementation functionalities as well as displays some of the error catching that has been included in the development of the program.

While not every single test case has been included, I feel that these driver programs exhaust a variety of possibilities that the user will run into. While read/write semaphores are not explicitly tested in either of these programs, I have confidence that they will work correctly if simultaneous processes wish to utilize this form of interprocess communication.
