# Asynchronous Message Passing

This project required us to come up with a way to create mailboxes and allow processes to send and receive messages to and from those mailboxes. To implement this in kernel space, I decided to make use of a linked list of linked lists. The first list would be the mailbox layer, with messages added to the given mailbox in the form of a list as well. In order to allow for messages to be stored in either a stack or queue (LIFO or FIFO), I made use the doubly linked list library <linux/list.h> in order to make my life a bit easier. This library allows you to add nodes to either the beginning or the end of an existing list, so creating the mailboxes as either stacks or queues was trivial. 

The requirements for this project included defining a couple key functionalities for our mailboxes:
1) `long create_mbox_421(unsigned long id, int enable_crypt, int lifo)`: creates a new empty mailbox with ID id, if it does not already exist, and returns 0. The queue should be flagged for encryption if the enable_crypt option is set to anything other than 0. If enable_crypt is set to zero, then the key parameter in any functions including it should be ignored. The lifo parameter controls what direction the messages are retrieved in. If this parameter is 0, then the messages should be stored/retrieved in FIFO order (as a queue). If it is non-zero, then the messages should be stored in LIFO order (as a stack).
2) `long remove_mbox_421(unsigned long id)`: removes mailbox with ID id, if it is empty, and returns 0. If the mailbox is not empty, this system call should return an appropriate error and not remove the mailbox.
3) `long count_mbox_421(void)`: returns the number of existing mailboxes.
4) `long list_mbox_421(unsigned long *mbxes, long k)`: returns a list of up to k mailbox IDs in the user-space variable mbxes. It returns the number of IDs written successfully to mbxes on success and an appropriate error code on failure.
5) `long send_msg_421(unsigned long id, unsigned char *msg, long n, unsigned long key)`: encrypts the message msg (if appropriate), adding it to the already existing mailbox identified. Returns the number of bytes stored (which should be equal to the message length n) on success, and an appropriate error code on failure. Messages with negative lengths shall be rejected as invalid and cause an appropriate error to be returned.
6) `long recv_msg_421(unsigned long id, unsigned char *msg, long n, unsigned long key)`: copies up to n characters from the next message in the mailbox id to the user-space buffer msg, decrypting with the specified key (if appropriate), and removes the entire message from the mailbox (even if only part of the message is copied out). Returns the number of bytes successfully copied (which should be the minimum of the length of the message that is stored and n) on success or an appropriate error code on failure.
7) `long peek_msg_421(unsigned long id, unsigned char *msg, long n, unsigned long key)`: performs the same operation as recv_msg_421() without removing the message from the mailbox.
8) `long count_msg_421(unsigned long id)`: returns the number of messages in the mailbox id on success or an appropriate error code on failure.
9) `long len_msg_421(unsigned long id)`: returns the lenth of the next message that would be returned by calling recv_msg_421() with the same id value (that is the number of bytes in the next message in the mailbox). If there are no messages in the mailbox, this should return an appropriate error value.
